## Assurance
The code authored as part of Iteration 2 is fit for its purpose, and is functional as required.
The backend codebase has been created in response to user criteria collected as part of Iteration 1,
and as a result meets the needs of the client (UNSW). Furthermore, through extensive testing utilising pytest
module, as well as coverage reports generated by the python coverage library, we can verify that
that the backend built as part of Iteration 2 is of high quality.

### Validation
The software produced in this iteration was constructed off of the specifications and requests of the client
which were gathered in Iteration 1 as user stories. In the previous iteration, these user stories were used
to create acceptance criteria, which populated the project's GitLab Issues Board as the specific functions
they were related to so that they could be viewed easily while building the software.

### Verification
After each branch of the software was written by their individual authors and merged into one codebase by the team,
extensive testing was done to ensure that the software functioned as required, and as a result was of high quality.

The tests were written to be utilised with the 'pytest' addon for python, and were designed in a way that would
ensure that it tested as much of the project as possible, as realistically as possible. These tests were run
alongside the 'coverage' addon which measured how many statements of our codebase was run, i.e. measuring how
extensive the tests were, and reported back an average of around 90%.

Furthermore, to ensure that our code was of high quality for maintenance's sake, we ran it through a linter,
more specifically 'pylint'. The purpose of this was to find any additional quirks in our code that our pytests
could not locate (such as warnings that it did not report), and more importantly, unify our code to a particular
standard/style such that it would be easy for programmers, ourselves or otherwise, to work with in the future.